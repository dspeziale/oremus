#!/usr/bin/env python3
"""
Script per estrarre le Lodi Mattutine dalla Liturgia delle Ore
Salva i dati sia in JSON che in database SQLite
"""
import os
import time
import requests
from bs4 import BeautifulSoup
import json
import sys
from datetime import datetime, timedelta
import html
import unicodedata
import sqlite3


def init_database(db_path="lodi_mattutine.db"):
    """
    Inizializza il database SQLite con le tabelle necessarie
    """
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    # Tabella principale delle Lodi
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS lodi (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        data TEXT UNIQUE NOT NULL,
        data_formattata TEXT,
        url_fonte TEXT,
        versetto_iniziale TEXT,
        risposta_versetto TEXT,
        dossologia_introduzione TEXT,
        nota_introduzione TEXT,
        benedizione_conclusione TEXT,
        risposta_conclusione TEXT,
        data_inserimento TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')

    # Tabella Inni
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS inni (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        lodi_id INTEGER,
        opzione INTEGER,
        lingua TEXT,
        testo TEXT,
        FOREIGN KEY (lodi_id) REFERENCES lodi(id)
    )
    ''')

    # Tabella Salmodia
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS salmodia (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        lodi_id INTEGER,
        numero INTEGER,
        antifona TEXT,
        titolo TEXT,
        sottotitolo TEXT,
        citazione_introduttiva TEXT,
        testo TEXT,
        tipo TEXT,
        FOREIGN KEY (lodi_id) REFERENCES lodi(id)
    )
    ''')

    # Tabella Lettura Breve
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS lettura_breve (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        lodi_id INTEGER,
        riferimento TEXT,
        testo TEXT,
        FOREIGN KEY (lodi_id) REFERENCES lodi(id)
    )
    ''')

    # Tabella Responsorio Breve
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS responsorio_breve (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        lodi_id INTEGER,
        testo TEXT,
        FOREIGN KEY (lodi_id) REFERENCES lodi(id)
    )
    ''')

    # Tabella Cantico Evangelico (Benedictus)
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS cantico_evangelico (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        lodi_id INTEGER,
        nome TEXT,
        riferimento TEXT,
        sottotitolo TEXT,
        antifona TEXT,
        testo TEXT,
        dossologia TEXT,
        FOREIGN KEY (lodi_id) REFERENCES lodi(id)
    )
    ''')

    # Tabella Invocazioni
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS invocazioni (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        lodi_id INTEGER,
        introduzione TEXT,
        ritornello TEXT,
        invocazioni_lista TEXT,
        padre_nostro TEXT,
        FOREIGN KEY (lodi_id) REFERENCES lodi(id)
    )
    ''')

    # Tabella Orazione
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS orazione (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        lodi_id INTEGER,
        testo TEXT,
        FOREIGN KEY (lodi_id) REFERENCES lodi(id)
    )
    ''')

    conn.commit()
    conn.close()
    print(f"âœ“ Database inizializzato: {db_path}")


def save_to_database(lodi_data, db_path="lodi_mattutine.db"):
    """
    Salva i dati delle Lodi nel database SQLite
    """
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    try:
        # Inserisci dati principali
        cursor.execute('''
        INSERT OR REPLACE INTO lodi 
        (data, data_formattata, url_fonte, versetto_iniziale, risposta_versetto, 
         dossologia_introduzione, nota_introduzione, benedizione_conclusione, risposta_conclusione)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            lodi_data['data'],
            lodi_data['data_formattata'],
            lodi_data['url_fonte'],
            lodi_data['introduzione']['versetto_iniziale']['versetto'],
            lodi_data['introduzione']['versetto_iniziale']['risposta'],
            lodi_data['introduzione']['dossologia'],
            lodi_data['introduzione']['nota'],
            lodi_data['conclusione']['benedizione'],
            lodi_data['conclusione']['risposta']
        ))

        lodi_id = cursor.lastrowid

        # Elimina dati precedenti correlati (per UPDATE)
        cursor.execute('DELETE FROM inni WHERE lodi_id = ?', (lodi_id,))
        cursor.execute('DELETE FROM salmodia WHERE lodi_id = ?', (lodi_id,))
        cursor.execute('DELETE FROM lettura_breve WHERE lodi_id = ?', (lodi_id,))
        cursor.execute('DELETE FROM responsorio_breve WHERE lodi_id = ?', (lodi_id,))
        cursor.execute('DELETE FROM cantico_evangelico WHERE lodi_id = ?', (lodi_id,))
        cursor.execute('DELETE FROM invocazioni WHERE lodi_id = ?', (lodi_id,))
        cursor.execute('DELETE FROM orazione WHERE lodi_id = ?', (lodi_id,))

        # Inserisci Inni
        cursor.execute('''
        INSERT INTO inni (lodi_id, opzione, lingua, testo)
        VALUES (?, 1, ?, ?)
        ''', (lodi_id,
              lodi_data['inno']['opzione_1']['lingua'],
              '\n'.join(lodi_data['inno']['opzione_1']['testo_completo'])))

        if lodi_data['inno']['opzione_2']['testo_completo']:
            cursor.execute('''
            INSERT INTO inni (lodi_id, opzione, lingua, testo)
            VALUES (?, 2, ?, ?)
            ''', (lodi_id,
                  lodi_data['inno']['opzione_2']['lingua'],
                  '\n'.join(lodi_data['inno']['opzione_2']['testo_completo'])))

        # Inserisci Salmodia
        for salmo in lodi_data['salmodia']:
            tipo = 'cantico' if 'titolo_cantico' in salmo and salmo['titolo_cantico'] else 'salmo'
            titolo = salmo.get('titolo_cantico', salmo.get('titolo_salmo', ''))

            cursor.execute('''
            INSERT INTO salmodia (lodi_id, numero, antifona, titolo, sottotitolo, 
                                 citazione_introduttiva, testo, tipo)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (lodi_id, salmo['numero'], salmo['antifona'], titolo,
                  salmo['sottotitolo'], salmo['citazione_introduttiva'],
                  '\n'.join(salmo['testo_completo']), tipo))

        # Inserisci Lettura Breve
        cursor.execute('''
        INSERT INTO lettura_breve (lodi_id, riferimento, testo)
        VALUES (?, ?, ?)
        ''', (lodi_id,
              lodi_data['lettura_breve']['riferimento'],
              lodi_data['lettura_breve']['testo_completo']))

        # Inserisci Responsorio Breve
        cursor.execute('''
        INSERT INTO responsorio_breve (lodi_id, testo)
        VALUES (?, ?)
        ''', (lodi_id, '\n'.join(lodi_data['responsorio_breve']['testo_completo'])))

        # Inserisci Cantico Evangelico
        cursor.execute('''
        INSERT INTO cantico_evangelico (lodi_id, nome, riferimento, sottotitolo, 
                                       antifona, testo, dossologia)
        VALUES (?, ?, ?, ?, ?, ?, ?)
        ''', (lodi_id,
              lodi_data['cantico_evangelico']['nome'],
              lodi_data['cantico_evangelico']['riferimento'],
              lodi_data['cantico_evangelico']['sottotitolo'],
              lodi_data['cantico_evangelico']['antifona'],
              '\n'.join(lodi_data['cantico_evangelico']['testo_completo']),
              lodi_data['cantico_evangelico']['dossologia']))

        # Inserisci Invocazioni
        cursor.execute('''
        INSERT INTO invocazioni (lodi_id, introduzione, ritornello, invocazioni_lista, padre_nostro)
        VALUES (?, ?, ?, ?, ?)
        ''', (lodi_id,
              lodi_data['invocazioni']['introduzione'],
              lodi_data['invocazioni']['ritornello'],
              json.dumps(lodi_data['invocazioni']['invocazioni_lista'], ensure_ascii=False),
              lodi_data['invocazioni']['padre_nostro']))

        # Inserisci Orazione
        cursor.execute('''
        INSERT INTO orazione (lodi_id, testo)
        VALUES (?, ?)
        ''', (lodi_id, lodi_data['orazione']['testo_completo']))

        conn.commit()
        return True

    except Exception as e:
        print(f"Errore nel salvataggio su database: {e}")
        conn.rollback()
        return False
    finally:
        conn.close()


def clean_text(text):
    """
    Pulisce il testo da caratteri speciali e HTML entities
    """
    if not text:
        return ""

    text = html.unescape(text)

    replacements = {
        'Ã¢â‚¬â„¢': "'", 'Ã¢â‚¬"': "â€”", 'Ã¢â‚¬Å“': '"', 'Ã¢â‚¬': '"',
        'ÃƒÂ¨': 'Ã¨', 'ÃƒÂ©': 'Ã©', 'ÃƒÂ¬': 'Ã¬', 'ÃƒÂ²': 'Ã²',
        'ÃƒÂ¹': 'Ã¹', 'Ãƒ ': 'Ã ', 'ÃƒË†': 'Ãˆ', 'Ã¢â‚¬ ': 'â€  ',
        '\u0001': '', 'â€ ': 'â€ ',
    }

    for old, new in replacements.items():
        text = text.replace(old, new)

    text = unicodedata.normalize('NFC', text)
    text = ''.join(
        char for char in text if char == '\n' or char == '\t' or not unicodedata.category(char).startswith('C'))

    return text.strip()


def estrai_tutti_testi_tra(testo, inizio, fine):
    """
    Estrae tutti i testi compresi tra due stringhe.

    Returns:
        list: Lista di tutti i testi estratti
    """
    risultati = []
    pos = 0

    while True:
        try:
            pos_inizio = testo.index(inizio, pos) + len(inizio)
            pos_fine = testo.index(fine, pos_inizio)
            risultati.append(testo[pos_inizio:pos_fine])
            pos = pos_fine + len(fine)
        except ValueError:
            break

    return risultati


# # Esempio
# testo = "Nome: <tag>Mario</tag> Cognome: <tag>Rossi</tag>"
# risultati = estrai_tutti_testi_tra(testo, "<tag>", "</tag>")
# print(risultati)  # Output: ['Mario', 'Rossi']

def extract_lodi(data_liturgia):
    """
    Estrae le Lodi Mattutine COMPLETE per la data specificata
    """
    url = f"https://www.chiesacattolica.it/la-liturgia-delle-ore/?data-liturgia={data_liturgia}&ora=lodi-mattutine"

    print(f"Recupero dati da: {url}")

    try:
        response = requests.get(url, timeout=30)
        response.encoding = 'utf-8'
        response.raise_for_status()
    except requests.RequestException as e:
        print(f"Errore nel recupero dei dati: {e}")
        return None

    soup = BeautifulSoup(response.content, 'html.parser', from_encoding='utf-8')
    risultati=estrai_tutti_testi_tra(str(soup),'<div class="row cci-liturgia-ore-menu-container">','Amen.</div>')
    print(risultati)
    soup=risultati

    lodi = {
        "data": data_liturgia,
        "data_formattata": format_date(data_liturgia),
        "tipo": "Lodi Mattutine",
        "url_fonte": url,
        "introduzione": {
            "versetto_iniziale": {"versetto": "", "risposta": ""},
            "dossologia": "",
            "nota": ""
        },
        "inno": {
            "opzione_1": {"lingua": "italiano", "testo_completo": []},
            "opzione_2": {"lingua": "latino", "testo_completo": []}
        },
        "salmodia": [
            {"numero": 1, "antifona": "", "titolo_salmo": "", "sottotitolo": "",
             "citazione_introduttiva": "", "testo_completo": []},
            {"numero": 2, "antifona": "", "titolo_cantico": "", "sottotitolo": "",
             "citazione_introduttiva": "", "testo_completo": []},
            {"numero": 3, "antifona": "", "titolo_salmo": "", "sottotitolo": "",
             "citazione_introduttiva": "", "testo_completo": []}
        ],
        "lettura_breve": {"riferimento": "", "testo_completo": ""},
        "responsorio_breve": {"testo_completo": []},
        "cantico_evangelico": {
            "nome": "Cantico di Zaccaria (Benedictus)",
            "riferimento": "Lc 1, 68-79",
            "sottotitolo": "", "antifona": "", "testo_completo": [], "dossologia": ""
        },
        "invocazioni": {
            "introduzione": "", "ritornello": "",
            "invocazioni_lista": [], "padre_nostro": "Padre nostro"
        },
        "orazione": {"testo_completo": ""},
        "conclusione": {"benedizione": "", "risposta": ""}
    }

    #page_text = soup.get_text(separator="\n")
    page_text = str(soup)
    lines = [clean_text(line) for line in page_text.split("\n") if clean_text(line)]

    i = 0
    inno_opzione = 1
    collecting_inno = False
    collecting_benedictus = False

    while i < len(lines):
        line = lines[i]

        if "O Dio, vieni a salvarmi" in line:
            lodi["introduzione"]["versetto_iniziale"]["versetto"] = clean_text("O Dio, vieni a salvarmi")
            i += 1
            if i < len(lines) and "R." in lines[i]:
                i += 1
            if i < len(lines):
                lodi["introduzione"]["versetto_iniziale"]["risposta"] = clean_text(lines[i])
            i += 1
            continue

        if "Gloria al Padre e al Figlio" in line and not collecting_benedictus:
            dossologia_lines = []
            while i < len(lines) and "Amen" not in lines[i]:
                dossologia_lines.append(clean_text(lines[i]))
                i += 1
            if i < len(lines) and "Amen" in lines[i]:
                dossologia_lines.append(clean_text(lines[i]))
                i += 1
            lodi["introduzione"]["dossologia"] = "\n".join(dossologia_lines)
            continue

        if "Questa introduzione si omette" in line:
            lodi["introduzione"]["nota"] = clean_text(line)
            i += 1
            continue

        if line == "INNO":
            collecting_inno = True
            inno_opzione = 1
            i += 1
            continue

        if collecting_inno and line == "Oppure:":
            inno_opzione = 2
            i += 1
            continue

        if collecting_inno and line.startswith("1 ant"):
            collecting_inno = False
            continue

        if collecting_inno:
            cleaned = clean_text(line)
            if cleaned:
                if inno_opzione == 1:
                    lodi["inno"]["opzione_1"]["testo_completo"].append(cleaned)
                else:
                    lodi["inno"]["opzione_2"]["testo_completo"].append(cleaned)
            i += 1
            continue

        if line == "1 ant.":
            salmo_idx = 0
            i += 1
            antifona_lines = []
            while i < len(lines) and not lines[i].startswith("SALMO"):
                antifona_lines.append(clean_text(lines[i]))
                i += 1
            lodi["salmodia"][salmo_idx]["antifona"] = " ".join(antifona_lines)

            if i < len(lines) and lines[i].startswith("SALMO"):
                lodi["salmodia"][salmo_idx]["titolo_salmo"] = clean_text(lines[i])
                i += 1

            sottotitolo_lines = []
            while i < len(lines) and not lines[i].startswith("("):
                sottotitolo_lines.append(clean_text(lines[i]))
                i += 1
            if sottotitolo_lines:
                lodi["salmodia"][salmo_idx]["sottotitolo"] = " ".join(sottotitolo_lines)

            if i < len(lines) and lines[i].startswith("("):
                citazione_lines = []
                while i < len(lines):
                    citazione_lines.append(clean_text(lines[i]))
                    if lines[i].endswith(").") or lines[i].endswith(")"):
                        i += 1
                        break
                    i += 1
                lodi["salmodia"][salmo_idx]["citazione_introduttiva"] = " ".join(citazione_lines)

            testo_lines = []
            while i < len(lines) and lines[i] != "1 ant.":
                cleaned = clean_text(lines[i])
                if cleaned:
                    testo_lines.append(cleaned)
                i += 1
            lodi["salmodia"][salmo_idx]["testo_completo"] = testo_lines

            if i < len(lines) and lines[i] == "1 ant.":
                i += 1
                while i < len(lines) and not (lines[i] == "2 ant." or lines[i] == "LETTURA BREVE"):
                    i += 1
            continue

        if line == "2 ant.":
            salmo_idx = 1
            i += 1
            antifona_lines = []
            while i < len(lines) and not lines[i].startswith("CANTICO"):
                antifona_lines.append(clean_text(lines[i]))
                i += 1
            lodi["salmodia"][salmo_idx]["antifona"] = " ".join(antifona_lines)

            if i < len(lines) and lines[i].startswith("CANTICO"):
                lodi["salmodia"][salmo_idx]["titolo_cantico"] = clean_text(lines[i])
                i += 1

            sottotitolo_lines = []
            while i < len(lines) and not lines[i].startswith("("):
                sottotitolo_lines.append(clean_text(lines[i]))
                i += 1
            if sottotitolo_lines:
                lodi["salmodia"][salmo_idx]["sottotitolo"] = " ".join(sottotitolo_lines)

            if i < len(lines) and lines[i].startswith("("):
                citazione_lines = []
                while i < len(lines):
                    citazione_lines.append(clean_text(lines[i]))
                    if lines[i].endswith(").") or lines[i].endswith(")"):
                        i += 1
                        break
                    i += 1
                lodi["salmodia"][salmo_idx]["citazione_introduttiva"] = " ".join(citazione_lines)

            testo_lines = []
            while i < len(lines) and lines[i] != "2 ant.":
                cleaned = clean_text(lines[i])
                if cleaned:
                    testo_lines.append(cleaned)
                i += 1
            lodi["salmodia"][salmo_idx]["testo_completo"] = testo_lines

            if i < len(lines) and lines[i] == "2 ant.":
                i += 1
                while i < len(lines) and not (lines[i] == "3 ant." or lines[i] == "LETTURA BREVE"):
                    i += 1
            continue

        if line == "3 ant.":
            salmo_idx = 2
            i += 1
            antifona_lines = []
            while i < len(lines) and not lines[i].startswith("SALMO"):
                antifona_lines.append(clean_text(lines[i]))
                i += 1
            lodi["salmodia"][salmo_idx]["antifona"] = " ".join(antifona_lines)

            if i < len(lines) and lines[i].startswith("SALMO"):
                lodi["salmodia"][salmo_idx]["titolo_salmo"] = clean_text(lines[i])
                i += 1

            sottotitolo_lines = []
            while i < len(lines) and not lines[i].startswith("("):
                sottotitolo_lines.append(clean_text(lines[i]))
                i += 1
            if sottotitolo_lines:
                lodi["salmodia"][salmo_idx]["sottotitolo"] = " ".join(sottotitolo_lines)

            if i < len(lines) and lines[i].startswith("("):
                citazione_lines = []
                while i < len(lines):
                    citazione_lines.append(clean_text(lines[i]))
                    if lines[i].endswith(").") or lines[i].endswith(")"):
                        i += 1
                        break
                    i += 1
                lodi["salmodia"][salmo_idx]["citazione_introduttiva"] = " ".join(citazione_lines)

            testo_lines = []
            while i < len(lines) and lines[i] != "3 ant." and lines[i] != "LETTURA BREVE":
                cleaned = clean_text(lines[i])
                if cleaned:
                    testo_lines.append(cleaned)
                i += 1
            lodi["salmodia"][salmo_idx]["testo_completo"] = testo_lines

            if i < len(lines) and lines[i] == "3 ant.":
                i += 1
                while i < len(lines) and lines[i] != "LETTURA BREVE":
                    i += 1
            continue

        if line == "LETTURA BREVE":
            i += 1
            if i < len(lines):
                lodi["lettura_breve"]["riferimento"] = clean_text(lines[i])
                i += 1
            lettura_lines = []
            while i < len(lines) and not lines[i].startswith("RESPONSORIO"):
                lettura_lines.append(clean_text(lines[i]))
                i += 1
            lodi["lettura_breve"]["testo_completo"] = "\n".join(lettura_lines)
            continue

        if line == "RESPONSORIO BREVE":
            i += 1
            responsorio_lines = []
            while i < len(lines) and not (lines[i].startswith("Ant") or "CANTICO" in lines[i]):
                cleaned = clean_text(lines[i])
                if cleaned:
                    responsorio_lines.append(cleaned)
                i += 1
            lodi["responsorio_breve"]["testo_completo"] = responsorio_lines
            continue

        if "Ant. al Ben" in line:
            i += 1
            antifona_ben_lines = []
            while i < len(lines) and not ("CANTICO" in lines[i]):
                antifona_ben_lines.append(clean_text(lines[i]))
                i += 1
            lodi["cantico_evangelico"]["antifona"] = "\n".join(antifona_ben_lines)
            continue

        if line == "CANTICO DI ZACCARIA":
            i += 1
            if i < len(lines) and lines[i].startswith("Lc"):
                lodi["cantico_evangelico"]["riferimento"] = clean_text(lines[i])
                i += 1
            if i < len(lines) and not lines[i].startswith("Benedetto"):
                lodi["cantico_evangelico"]["sottotitolo"] = clean_text(lines[i])
                i += 1
            collecting_benedictus = True
            continue

        if collecting_benedictus:
            if "Ant. al Ben" in line:
                collecting_benedictus = False
                i += 1
                while i < len(lines) and lines[i] != "INVOCAZIONI":
                    i += 1
                continue

            if line == "INVOCAZIONI":
                collecting_benedictus = False
                continue

            if "Gloria al Padre" in line:
                doss_lines = []
                while i < len(lines) and "Amen" not in lines[i]:
                    doss_lines.append(clean_text(lines[i]))
                    i += 1
                if i < len(lines):
                    doss_lines.append(clean_text(lines[i]))
                    i += 1
                lodi["cantico_evangelico"]["dossologia"] = "\n".join(doss_lines)
                continue

            cleaned = clean_text(line)
            if cleaned:
                lodi["cantico_evangelico"]["testo_completo"].append(cleaned)
            i += 1
            continue

        if line == "INVOCAZIONI":
            i += 1
            intro_lines = []
            while i < len(lines) and not ("GesÃ¹" in lines[i] or "Cristo" in lines[i]):
                intro_lines.append(clean_text(lines[i]))
                i += 1
            lodi["invocazioni"]["introduzione"] = "\n".join(intro_lines)

            ritornello_lines = []
            while i < len(lines) and lines[i] != "â€”":
                ritornello_lines.append(clean_text(lines[i]))
                i += 1
            lodi["invocazioni"]["ritornello"] = "\n".join(ritornello_lines)

            invocazioni_list = []
            current_invocazione = []

            while i < len(lines) and not lines[i].startswith("Padre nostro"):
                if lines[i] == "â€”":
                    if current_invocazione:
                        invocazioni_list.append("\n".join(current_invocazione))
                    current_invocazione = []
                    i += 1
                    while i < len(lines) and lines[i] != "â€”" and not lines[i].startswith("Padre nostro"):
                        cleaned = clean_text(lines[i])
                        if cleaned:
                            current_invocazione.append(cleaned)
                        i += 1
                else:
                    i += 1

            if current_invocazione:
                invocazioni_list.append("\n".join(current_invocazione))

            lodi["invocazioni"]["invocazioni_lista"] = invocazioni_list

            if i < len(lines) and "Padre nostro" in lines[i]:
                i += 1
            continue

        if line == "ORAZIONE":
            i += 1
            orazione_lines = []
            while i < len(lines) and not lines[i].startswith("Il Signore"):
                orazione_lines.append(clean_text(lines[i]))
                i += 1
            lodi["orazione"]["testo_completo"] = " ".join(orazione_lines)
            continue

        if "Il Signore ci benedica" in line:
            lodi["conclusione"]["benedizione"] = clean_text(line)
            i += 1
            if i < len(lines) and "R." in lines[i]:
                i += 1
            if i < len(lines):
                lodi["conclusione"]["risposta"] = clean_text(lines[i])
            break

        i += 1

    return lodi


def format_date(date_string):
    """Formatta la data da YYYYMMDD a formato leggibile italiano"""
    try:
        date_obj = datetime.strptime(date_string, "%Y%m%d")
        giorni = ["LunedÃ¬", "MartedÃ¬", "MercoledÃ¬", "GiovedÃ¬", "VenerdÃ¬", "Sabato", "Domenica"]
        mesi = ["gennaio", "febbraio", "marzo", "aprile", "maggio", "giugno",
                "luglio", "agosto", "settembre", "ottobre", "novembre", "dicembre"]

        giorno_settimana = giorni[date_obj.weekday()]
        giorno = date_obj.day
        mese = mesi[date_obj.month - 1]
        anno = date_obj.year

        return f"{giorno_settimana} {giorno} {mese} {anno}"
    except:
        return date_string


def extract_lodi_range(data_inizio, data_fine, output_dir="lodi_json_fixed", db_path="lodi_mattutine.db"):
    """Estrae le Lodi per un range di date"""
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # Inizializza il database
    init_database(db_path)

    try:
        dt_inizio = datetime.strptime(data_inizio, "%Y%m%d")
        dt_fine = datetime.strptime(data_fine, "%Y%m%d")
    except ValueError:
        print("âŒ Errore: formato data non valido. Usa YYYYMMDD")
        return None

    if dt_inizio > dt_fine:
        print("âŒ Errore: la data di inizio deve essere precedente alla data di fine")
        return None

    delta = dt_fine - dt_inizio
    num_giorni = delta.days + 1

    print("\n" + "=" * 60)
    print(f"ESTRAZIONE LODI MATTUTINE - RANGE (CON DATABASE SQLITE)")
    print("=" * 60)
    print(f"Data inizio: {format_date(data_inizio)}")
    print(f"Data fine: {format_date(data_fine)}")
    print(f"Numero giorni: {num_giorni}")
    print(f"Directory JSON: {output_dir}/")
    print(f"Database SQLite: {db_path}")
    print("=" * 60 + "\n")

    stats = {
        "totale": num_giorni,
        "successo": 0,
        "errori": 0,
        "files": []
    }

    current_date = dt_inizio
    for i in range(num_giorni):
        data_str = current_date.strftime("%Y%m%d")

        print(f"[{i + 1}/{num_giorni}] Estrazione {format_date(data_str)}...", end=" ")

        lodi = extract_lodi(data_str)

        if lodi:
            # Salva JSON
            output_file = os.path.join(output_dir, f"lodi_{data_str}.json")
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(lodi, f, ensure_ascii=False, indent=2)

            file_size = os.path.getsize(output_file)
            size_str = f"{file_size / 1024:.2f} KB" if file_size >= 1024 else f"{file_size} bytes"

            # Salva nel database
            db_saved = save_to_database(lodi, db_path)

            if db_saved:
                print(f"âœ“ OK (JSON: {size_str}, DB: âœ“)")
            else:
                print(f"âœ“ JSON OK ({size_str}), DB: âœ—")

            stats["successo"] += 1
            stats["files"].append(output_file)
        else:
            print("âœ— ERRORE")
            stats["errori"] += 1

        current_date += timedelta(days=1)

        if i < num_giorni - 1:
            time.sleep(0.5)

    print("\n" + "=" * 60)
    print("RIEPILOGO ESTRAZIONE")
    print("=" * 60)
    print(f"âœ“ Successo: {stats['successo']}/{stats['totale']}")
    if stats['errori'] > 0:
        print(f"âœ— Errori: {stats['errori']}/{stats['totale']}")
    print(f"ðŸ“ Files JSON salvati in: {output_dir}/")
    print(f"ðŸ—„ï¸  Database SQLite: {db_path}")
    print("=" * 60 + "\n")

    return stats


def query_database_example(db_path="lodi_mattutine.db"):
    """
    Esempio di query sul database
    """
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    print("\n" + "=" * 60)
    print("ESEMPIO DI QUERY SUL DATABASE")
    print("=" * 60)

    # Conta i record
    cursor.execute("SELECT COUNT(*) FROM lodi")
    count = cursor.fetchone()[0]
    print(f"\nNumero totale di Lodi nel database: {count}")

    # Mostra le ultime 5 date
    cursor.execute("""
        SELECT data, data_formattata 
        FROM lodi 
        ORDER BY data DESC 
        LIMIT 5
    """)
    print("\nUltime 5 date nel database:")
    for row in cursor.fetchall():
        print(f"  - {row[0]}: {row[1]}")

    # Esempio: ricerca per data
    cursor.execute("""
        SELECT l.data_formattata, o.testo
        FROM lodi l
        JOIN orazione o ON l.id = o.lodi_id
        WHERE l.data = ?
    """, ("20251015",))

    result = cursor.fetchone()
    if result:
        print(f"\nOrazione del {result[0]}:")
        print(f"  {result[1][:100]}...")

    conn.close()
    print("=" * 60 + "\n")


def main():
    sys.argv.append('20251015')
    sys.argv.append('20251031')

    if len(sys.argv) == 3:
        data_inizio = sys.argv[1]
        data_fine = sys.argv[2]
        stats = extract_lodi_range(data_inizio, data_fine)

        # Mostra esempio di query
        if stats and stats['successo'] > 0:
            query_database_example()

    elif len(sys.argv) == 2:
        data_liturgia = sys.argv[1]

        # Inizializza database
        db_path = "lodi_mattutine.db"
        init_database(db_path)

        lodi = extract_lodi(data_liturgia)

        if lodi:
            # Salva JSON
            output_file = f"lodi_{data_liturgia}_fixed.json"
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(lodi, f, ensure_ascii=False, indent=2)
            print(f"âœ“ File JSON creato: {output_file}")

            # Salva nel database
            if save_to_database(lodi, db_path):
                print(f"âœ“ Dati salvati nel database: {db_path}")
            else:
                print(f"âœ— Errore nel salvataggio su database")

    else:
        print("Uso: python lodi_extractor_sqlite.py YYYYMMDD")
        print("     python lodi_extractor_sqlite.py YYYYMMDD YYYYMMDD (range)")
        print("\nIl programma salverÃ  i dati sia in formato JSON che in database SQLite")


if __name__ == "__main__":
    main()